var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { sha256 } from '@noble/hashes/sha256';
import { Convert } from '@web5/common';
import { EcdsaAlgorithm, EdDsaAlgorithm } from '@web5/crypto';
import { DidResolver, isVerificationMethod } from './did-resolver.js';
import canonicalize from 'canonicalize';
var secp256k1Signer = {
    signer: new EcdsaAlgorithm(),
    options: { name: 'ECDSA' },
    alg: 'ES256K',
    crv: 'secp256k1'
};
var ed25519Signer = {
    signer: new EdDsaAlgorithm(),
    options: { name: 'EdDSA' },
    alg: 'EdDSA',
    crv: 'Ed25519'
};
/**
 * Cryptographic utility functions, such as hashing, signing, and verifying
 * @beta
 */
var Crypto = /** @class */ (function () {
    function Crypto() {
    }
    /**
     * Computes a digest of the payload by:
     * * JSON serializing the payload as per [RFC-8785: JSON Canonicalization Scheme](https://www.rfc-editor.org/rfc/rfc8785)
     * * sha256 hashing the serialized payload
     *
     * @returns The SHA-256 hash of the canonicalized payload, represented as a byte array.
     */
    Crypto.digest = function (payload) {
        // @ts-ignore
        var canonicalized = canonicalize(payload);
        var canonicalizedBytes = Convert.string(canonicalized).toUint8Array();
        return sha256(canonicalizedBytes);
    };
    /**
     * Signs the provided payload and produces a compact JSON Web Signature (JWS).
     *
     * @param opts - The options required for signing.
     * @returns A promise that resolves to the generated compact JWS.
     * @throws Will throw an error if the specified algorithm is not supported.
     */
    Crypto.sign = function (opts) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var did, payload, detached, privateKeyJwk, algorithmName, namedCurve, algorithmId, algorithm, verificationMethodId, jwsHeader, base64UrlEncodedJwsHeader, base64urlEncodedJwsPayload, toSign, toSignBytes, signatureBytes, base64UrlEncodedSignature;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        did = opts.did, payload = opts.payload, detached = opts.detached;
                        privateKeyJwk = (_b = (_a = did.keySet.verificationMethodKeys) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.privateKeyJwk;
                        algorithmName = (privateKeyJwk === null || privateKeyJwk === void 0 ? void 0 : privateKeyJwk['alg']) || '';
                        namedCurve = Crypto.extractNamedCurve(privateKeyJwk);
                        algorithmId = "".concat(algorithmName, ":").concat(namedCurve);
                        algorithm = this.algorithms[algorithmId];
                        if (!algorithm) {
                            throw new Error("Algorithm (".concat(algorithmId, ") not supported"));
                        }
                        verificationMethodId = ((_d = (_c = did.document.verificationMethod) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.id) || '';
                        if (verificationMethodId.startsWith('#')) {
                            verificationMethodId = "".concat(did.did).concat(verificationMethodId);
                        }
                        jwsHeader = { alg: algorithm.alg, kid: verificationMethodId };
                        base64UrlEncodedJwsHeader = Convert.object(jwsHeader).toBase64Url();
                        base64urlEncodedJwsPayload = Convert.uint8Array(payload).toBase64Url();
                        toSign = "".concat(base64UrlEncodedJwsHeader, ".").concat(base64urlEncodedJwsPayload);
                        toSignBytes = Convert.string(toSign).toUint8Array();
                        return [4 /*yield*/, algorithm.signer.sign({ key: privateKeyJwk, data: toSignBytes, algorithm: algorithm.options })];
                    case 1:
                        signatureBytes = _e.sent();
                        base64UrlEncodedSignature = Convert.uint8Array(signatureBytes).toBase64Url();
                        if (detached) {
                            // compact JWS with detached content: https://datatracker.ietf.org/doc/html/rfc7515#appendix-F
                            return [2 /*return*/, "".concat(base64UrlEncodedJwsHeader, "..").concat(base64UrlEncodedSignature)];
                        }
                        else {
                            return [2 /*return*/, "".concat(base64UrlEncodedJwsHeader, ".").concat(base64urlEncodedJwsPayload, ".").concat(base64UrlEncodedSignature)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Verifies the integrity of a message or resource's signature.
     *
     * @param opts - The options required for verification.
     * @returns A promise that resolves to the DID of the signer if verification is successful.
     * @throws Various errors related to invalid input or failed verification.
     */
    Crypto.verify = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            var signature, detachedPayload, splitJws, base64UrlEncodedJwsHeader, base64urlEncodedJwsPayload, base64UrlEncodedSignature, jwsHeader, dereferenceResult, verificationMethod, publicKeyJwk, signedData, signedDataBytes, signatureBytes, algorithmId, _a, signer, options, isLegit, did;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        signature = opts.signature, detachedPayload = opts.detachedPayload;
                        if (!signature) {
                            throw new Error('Signature verification failed: Expected signature property to exist');
                        }
                        splitJws = signature.split('.');
                        if (splitJws.length !== 3) {
                            throw new Error('Signature verification failed: Expected valid JWS with detached content');
                        }
                        base64UrlEncodedJwsHeader = splitJws[0], base64urlEncodedJwsPayload = splitJws[1], base64UrlEncodedSignature = splitJws[2];
                        if (detachedPayload) {
                            if (base64urlEncodedJwsPayload.length !== 0) { // ensure that JWS payload is empty
                                throw new Error('Signature verification failed: Expected valid JWS with detached content');
                            }
                            base64urlEncodedJwsPayload = Convert.uint8Array(detachedPayload).toBase64Url();
                        }
                        jwsHeader = Convert.base64Url(base64UrlEncodedJwsHeader).toObject();
                        if (!jwsHeader.alg || !jwsHeader.kid) { // ensure that JWS header has required properties
                            throw new Error('Signature verification failed: Expected JWS header to contain alg and kid');
                        }
                        return [4 /*yield*/, DidResolver.dereference({ didUrl: jwsHeader.kid })];
                    case 1:
                        dereferenceResult = _b.sent();
                        verificationMethod = dereferenceResult.contentStream;
                        if (!isVerificationMethod(verificationMethod)) { // ensure that appropriate verification method was found
                            throw new Error('Signature verification failed: Expected kid in JWS header to dereference to a DID Document Verification Method');
                        }
                        publicKeyJwk = verificationMethod.publicKeyJwk;
                        if (!publicKeyJwk) { // ensure that Verification Method includes public key as a JWK.
                            throw new Error('Signature verification failed: Expected kid in JWS header to dereference to a DID Document Verification Method with publicKeyJwk');
                        }
                        signedData = "".concat(base64UrlEncodedJwsHeader, ".").concat(base64urlEncodedJwsPayload);
                        signedDataBytes = Convert.string(signedData).toUint8Array();
                        signatureBytes = Convert.base64Url(base64UrlEncodedSignature).toUint8Array();
                        algorithmId = "".concat(jwsHeader['alg'], ":").concat(Crypto.extractNamedCurve(publicKeyJwk));
                        _a = Crypto.algorithms[algorithmId], signer = _a.signer, options = _a.options;
                        return [4 /*yield*/, signer.verify({ algorithm: options, key: publicKeyJwk, data: signedDataBytes, signature: signatureBytes })];
                    case 2:
                        isLegit = _b.sent();
                        if (!isLegit) {
                            throw new Error('Signature verification failed: Integrity mismatch');
                        }
                        did = jwsHeader.kid.split('#')[0];
                        return [2 /*return*/, did];
                }
            });
        });
    };
    /**
     * Gets crv property from a PublicKeyJwk or PrivateKeyJwk. Returns empty string if crv is undefined.
     */
    Crypto.extractNamedCurve = function (jwk) {
        if (jwk && 'crv' in jwk) {
            return jwk.crv;
        }
        else {
            return '';
        }
    };
    /** supported cryptographic algorithms. keys are `${alg}:${crv}`. */
    Crypto.algorithms = {
        'ES256K:': secp256k1Signer,
        'ES256K:secp256k1': secp256k1Signer,
        ':secp256k1': secp256k1Signer,
        'EdDSA:Ed25519': ed25519Signer
    };
    return Crypto;
}());
export { Crypto };
