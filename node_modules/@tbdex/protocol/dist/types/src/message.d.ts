import type { MessageKind, MessageKindModel, MessageModel, MessageMetadata, NewMessage } from './types.js';
import type { Rfq, Quote, Order, OrderStatus, Close } from './message-kinds/index.js';
import type { MessageKindClass } from './message-kinds/index.js';
import { PortableDid } from '@web5/dids';
/**
 * Representation of the protocol messages.
 * It also provides helper functions to manipulate raw messages, JSON and parsing.
 * @beta
 */
export declare abstract class Message<T extends MessageKind> {
    private _metadata;
    private _data;
    private _signature;
    /**
     * used by {@link Message.parse} to return an instance of message kind's class. This abstraction is needed
     * because importing the Message Kind classes (e.g. Rfq, Quote) creates a circular dependency
     * due to each concrete MessageKind class extending Message
    */
    static factory: <T extends MessageKind>(jsonMessage: MessageModel<T>) => MessageKindClass;
    constructor(jsonMessage: NewMessage<T>);
    /**
     * parses the json message into a message instance. performs format validation and an integrity check on the signature
     * @param message - the message to parse. can either be an object or a string
     * @returns {@link Message}
     */
    static parse<T extends MessageKind>(message: MessageModel<T> | string): Promise<MessageKindClass>;
    /**
     * validates the message and verifies the cryptographic signature
     * @throws if the message is invalid
     * @throws see {@link Crypto.verify}
     * @returns Message signer's DID
     */
    static verify<T extends MessageKind>(message: MessageModel<T> | Message<T>): Promise<string>;
    /** Generates a unique id with the message kind's prefix */
    static generateId(messageKind: MessageKind): string;
    /**
     * validates the message provided against the appropriate json schemas.
     * 2-phased validation: First validates the message structure and then
     * validates `data` based on the value of `metadata.kind`
     * @param jsonMessage - the message to validate
     *
     * @throws `Error` if validation fails
     */
    static validate(jsonMessage: any): void;
    /**
     * Validates `data` section of message only. This is useful for partially validating
     * unsigned Messages.
     */
    static validateData(kind: string, messageData: any): void;
    /**
     * returns an instance of the appropriate MessageKind class based on the value of `jsonMessage.metadata.kind`
     * @param jsonMessage - the message to parse
     */
    static fromJson<T extends MessageKind>(jsonMessage: MessageModel<T>): MessageKindClass;
    /**
     * signs the message as a jws with detached content and sets the signature property
     * @param did - the signer's DID
     */
    sign(did: PortableDid): Promise<void>;
    /**
     * validates the message and verifies the cryptographic signature
     * @throws if the message is invalid
     * @throws see {@link Crypto.verify}
     * @returns Signer's DID
     */
    verify(): Promise<string>;
    /** The metadata object contains fields about the message and is present in every tbdex message. */
    get metadata(): MessageMetadata<T>;
    /** the message kind's content */
    get data(): MessageKindModel<T>;
    /** the message's cryptographic signature */
    get signature(): string | undefined;
    /** the message id */
    get id(): string;
    /** ID for an "exchange" of messages between Alice - PFI. Uses the id of the RFQ that initiated the exchange */
    get exchangeId(): string;
    /** the message kind (e.g. rfq, quote) */
    get kind(): T;
    /** The sender's DID */
    get from(): string;
    /** the recipient's DID */
    get to(): string;
    /** Message creation time. Expressed as ISO8601 */
    get createdAt(): string;
    /** Rfq type guard */
    isRfq(): this is Rfq;
    /** Quote type guard */
    isQuote(): this is Quote;
    /** Order type guard */
    isOrder(): this is Order;
    /** OrderStatus type guard */
    isOrderStatus(): this is OrderStatus;
    /** Close type guard */
    isClose(): this is Close;
    /**
     * returns the message as a json object. Automatically used by `JSON.stringify` method.
     * @throws if message is missing signature
     */
    toJSON(): MessageModel<T>;
}
//# sourceMappingURL=message.d.ts.map