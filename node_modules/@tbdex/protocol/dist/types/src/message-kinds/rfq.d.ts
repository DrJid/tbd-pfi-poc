import type { MessageKind, MessageKindModel, MessageMetadata, ResourceModel, SelectedPaymentMethod } from '../types.js';
import { Offering } from '../resource-kinds/index.js';
import { Message } from '../message.js';
/**
 * Options passed to {@link Rfq.create}
 * @beta
 */
export type CreateRfqOptions = {
    data: MessageKindModel<'rfq'>;
    metadata: Omit<MessageMetadata<'rfq'>, 'id' | 'kind' | 'createdAt' | 'exchangeId'>;
    private?: Record<string, any>;
};
/**
 * Message sent by Alice to PFI to requesting for a quote (RFQ)
 * @beta
 */
export declare class Rfq extends Message<'rfq'> {
    /** a set of valid Message kinds that can come after an rfq */
    readonly validNext: Set<MessageKind>;
    /** private data (PII or PCI) */
    _private: Record<string, any> | undefined;
    /**
     * Creates an rfq with the given options
     * @param opts - options to create an rfq
     * @returns {@link Rfq}
     */
    static create(opts: CreateRfqOptions): Rfq;
    /**
     * evaluates this rfq against the provided offering
     * @param offering - the offering to evaluate this rfq against
     * @throws if {@link Rfq.offeringId} doesn't match the provided offering's id
     * @throws if {@link Rfq.payinAmount} exceeds the provided offering's max units allowed or is below the offering's min units allowed
     * @throws if {@link Rfq.payinMethod} property `kind` cannot be validated against the provided offering's payinMethod kinds
     * @throws if {@link Rfq.payinMethod} property `paymentDetails` cannot be validated against the provided offering's payinMethod requiredPaymentDetails
     * @throws if {@link Rfq.payoutMethod} property `kind` cannot be validated against the provided offering's payoutMethod kinds
     * @throws if {@link Rfq.payoutMethod} property `paymentDetails` cannot be validated against the provided offering's payoutMethod requiredPaymentDetails
     */
    verifyOfferingRequirements(offering: Offering | ResourceModel<'offering'>): Promise<void>;
    /**
     * Validate the Rfq's payin/payout method against an Offering's allow payin/payout methods
     *
     * @param rfqPaymentMethod - The Rfq's selected payin/payout method being validated
     * @param allowedPaymentMethods - The Offering's allowed payin/payout methods
     *
     * @throws if {@link Rfq.payinMethod} property `kind` cannot be validated against the provided offering's payinMethod kinds
     * @throws if {@link Rfq.payinMethod} property `paymentDetails` cannot be validated against the provided offering's payinMethod requiredPaymentDetails
     * @throws if {@link Rfq.payoutMethod} property `kind` cannot be validated against the provided offering's payoutMethod kinds
     * @throws if {@link Rfq.payoutMethod} property `paymentDetails` cannot be validated against the provided offering's payoutMethod requiredPaymentDetails
     */
    private verifyPaymentMethod;
    /**
     * checks the claims provided in this rfq against an offering's requirements
     * @param offering - the offering to check against
     * @throws if rfq's claims do not fulfill the offering's requirements
     */
    verifyClaims(offering: Offering | ResourceModel<'offering'>): Promise<void>;
    /** Offering which Alice would like to get a quote for */
    get offeringId(): string;
    /** Amount of payin currency you want to spend in order to receive payout currency */
    get payinAmount(): string;
    /** Array of claims that satisfy the respective offering's requiredClaims */
    get claims(): string[];
    /** Selected payment method that Alice will use to send the listed payin currency to the PFI. */
    get payinMethod(): SelectedPaymentMethod;
    /** Selected payment method that the PFI will use to send the listed payout currency to Alice */
    get payoutMethod(): SelectedPaymentMethod;
    /**
     * Converts this rfq message to a json object
     */
    toJSON(): import("../types.js").MessageModel<"rfq">;
}
//# sourceMappingURL=rfq.d.ts.map