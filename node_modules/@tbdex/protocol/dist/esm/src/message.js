import { validate } from './validator.js';
import { Crypto } from './crypto.js';
import { typeid } from 'typeid-js';
/**
 * Representation of the protocol messages.
 * It also provides helper functions to manipulate raw messages, JSON and parsing.
 * @beta
 */
export class Message {
    _metadata;
    _data;
    _signature;
    /**
     * used by {@link Message.parse} to return an instance of message kind's class. This abstraction is needed
     * because importing the Message Kind classes (e.g. Rfq, Quote) creates a circular dependency
     * due to each concrete MessageKind class extending Message
    */
    static factory;
    constructor(jsonMessage) {
        this._metadata = jsonMessage.metadata;
        this._data = jsonMessage.data;
        this._signature = jsonMessage.signature;
    }
    /**
     * parses the json message into a message instance. performs format validation and an integrity check on the signature
     * @param message - the message to parse. can either be an object or a string
     * @returns {@link Message}
     */
    static async parse(message) {
        let jsonMessage;
        try {
            jsonMessage = typeof message === 'string' ? JSON.parse(message) : message;
        }
        catch (e) {
            const errorMessage = e instanceof Error ? e.message : e;
            throw new Error(`parse: Failed to parse message. Error: ${errorMessage}`);
        }
        await Message.verify(jsonMessage);
        return Message.factory(jsonMessage);
    }
    /**
     * validates the message and verifies the cryptographic signature
     * @throws if the message is invalid
     * @throws see {@link Crypto.verify}
     * @returns Message signer's DID
     */
    static async verify(message) {
        let jsonMessage = message instanceof Message ? message.toJSON() : message;
        Message.validate(jsonMessage);
        const digest = Crypto.digest({ metadata: jsonMessage.metadata, data: jsonMessage.data });
        // Message.validate() guarantees presence of signature
        const signer = await Crypto.verify({ detachedPayload: digest, signature: jsonMessage.signature });
        if (jsonMessage.metadata.from !== signer) { // ensure that DID used to sign matches `from` property in metadata
            throw new Error('Signature verification failed: Expected DID in kid of JWS header must match metadata.from');
        }
        return signer;
    }
    /** Generates a unique id with the message kind's prefix */
    static generateId(messageKind) {
        return typeid(messageKind).toString();
    }
    /**
     * validates the message provided against the appropriate json schemas.
     * 2-phased validation: First validates the message structure and then
     * validates `data` based on the value of `metadata.kind`
     * @param jsonMessage - the message to validate
     *
     * @throws `Error` if validation fails
     */
    static validate(jsonMessage) {
        // validate the message structure
        validate(jsonMessage, 'message');
        // validate the value of `data`
        validate(jsonMessage['data'], jsonMessage['metadata']['kind']);
    }
    /**
     * Validates `data` section of message only. This is useful for partially validating
     * unsigned Messages.
     */
    static validateData(kind, messageData) {
        // validate the value of `data`
        validate(messageData, kind);
    }
    /**
     * returns an instance of the appropriate MessageKind class based on the value of `jsonMessage.metadata.kind`
     * @param jsonMessage - the message to parse
     */
    static fromJson(jsonMessage) {
        return Message.factory(jsonMessage);
    }
    /**
     * signs the message as a jws with detached content and sets the signature property
     * @param did - the signer's DID
     */
    async sign(did) {
        const payload = { metadata: this.metadata, data: this.data };
        const payloadDigest = Crypto.digest(payload);
        this._signature = await Crypto.sign({ did: did, payload: payloadDigest, detached: true });
    }
    /**
     * validates the message and verifies the cryptographic signature
     * @throws if the message is invalid
     * @throws see {@link Crypto.verify}
     * @returns Signer's DID
     */
    async verify() {
        return Message.verify(this);
    }
    /** The metadata object contains fields about the message and is present in every tbdex message. */
    get metadata() {
        return this._metadata;
    }
    /** the message kind's content */
    get data() {
        return this._data;
    }
    /** the message's cryptographic signature */
    get signature() {
        return this._signature;
    }
    /** the message id */
    get id() {
        return this.metadata.id;
    }
    /** ID for an "exchange" of messages between Alice - PFI. Uses the id of the RFQ that initiated the exchange */
    get exchangeId() {
        return this.metadata.exchangeId;
    }
    /** the message kind (e.g. rfq, quote) */
    get kind() {
        return this.metadata.kind;
    }
    /** The sender's DID */
    get from() {
        return this.metadata.from;
    }
    /** the recipient's DID */
    get to() {
        return this.metadata.to;
    }
    /** Message creation time. Expressed as ISO8601 */
    get createdAt() {
        return this.metadata.createdAt;
    }
    /** Rfq type guard */
    isRfq() {
        return this.metadata.kind === 'rfq';
    }
    /** Quote type guard */
    isQuote() {
        return this.metadata.kind === 'quote';
    }
    /** Order type guard */
    isOrder() {
        return this.metadata.kind === 'order';
    }
    /** OrderStatus type guard */
    isOrderStatus() {
        return this.metadata.kind === 'orderstatus';
    }
    /** Close type guard */
    isClose() {
        return this.metadata.kind === 'close';
    }
    /**
     * returns the message as a json object. Automatically used by `JSON.stringify` method.
     * @throws if message is missing signature
     */
    toJSON() {
        const message = {
            metadata: this.metadata,
            data: this.data,
            signature: this.signature
        };
        return message;
    }
}
